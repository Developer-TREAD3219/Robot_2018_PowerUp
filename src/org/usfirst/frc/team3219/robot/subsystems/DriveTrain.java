// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc.team3219.robot.subsystems;

import org.usfirst.frc.team3219.robot.RobotMap;
import org.usfirst.frc.team3219.robot.commands.StickDrive;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrain extends Subsystem {
	private static final int CURRENT_LIMIT_TIMEOUT = 100;
	private static final int MINIMUM_CURRENT_LIMIT = 5;
	public static final boolean HIGH_GEAR = true;
	public static final boolean LOW_GEAR = false;
	

	public static final double CORRECTION_FACTOR = (12.2/10)*(10.276/10);
	public static final double TICKS_PER_REVOLUTION = 360.0;
	public static final double WHEEL_DIAMETER = 6.0;
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	private final WPI_TalonSRX frontLeft = RobotMap.driveTrainFrontLeft;
	private final WPI_TalonSRX backLeft = RobotMap.driveTrainBackLeft;
	private final SpeedControllerGroup leftDrive = RobotMap.driveTrainLeftDrive;
	private final WPI_TalonSRX frontRight = RobotMap.driveTrainFrontRight;
	private final WPI_TalonSRX backRight = RobotMap.driveTrainBackRight;
	private final SpeedControllerGroup rightDrive = RobotMap.driveTrainRightDrive;
	private final DifferentialDrive differentialDrive1 = RobotMap.driveTrainDifferentialDrive;
	private final Encoder leftEncoder = RobotMap.leftEncoder;
	private final Encoder rightEncoder = RobotMap.rightEncoder;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	@Override
	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		setDefaultCommand(new StickDrive());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public double leftDistance() {
		return leftEncoder.getDistance();
	}

	public double rightDistance() {
		return rightEncoder.getDistance();
	}
	
	public double robotCenterDistance() {
		return (((leftDistance() + rightDistance()) / 2)*CORRECTION_FACTOR);
	}
	
	public void resetDistance() {
		leftEncoder.reset();
		rightEncoder.reset();
	}
	
public void init() {
	double distancePerRev = (Math.PI * WHEEL_DIAMETER);
	double distancePerTick = (distancePerRev / TICKS_PER_REVOLUTION);
	leftEncoder.setDistancePerPulse(distancePerTick);
	rightEncoder.setDistancePerPulse(distancePerTick);
	leftEncoder.setReverseDirection(true);

	
	leftDrive.setInverted(false);
	rightDrive.setInverted(false);
	this.backLeft.configContinuousCurrentLimit(MINIMUM_CURRENT_LIMIT, CURRENT_LIMIT_TIMEOUT);
	this.backRight.configContinuousCurrentLimit(MINIMUM_CURRENT_LIMIT, CURRENT_LIMIT_TIMEOUT);

	differentialDrive1.setSafetyEnabled(true);
    differentialDrive1.setExpiration(0.1);
    differentialDrive1.setMaxOutput(1.0);
}
	public void setSafety(boolean safety) {
		differentialDrive1.setSafetyEnabled(safety);
	}
	
	@Override
	public void periodic() {
		// Put code here to be run every loop

	}
	
	public void stop() {
		this.drive(0, 0);
	}

	// Put methods for controlling this subsystem
	// here. Call these from Commands.
	
	public void shift(boolean input) {
		if(input == HIGH_GEAR) {
			RobotMap.DriveShifter.set(HIGH_GEAR);
		} else {
			RobotMap.DriveShifter.set(LOW_GEAR);
		}
	}

	public void drive(double leftPower, double rightPower) {
		this.differentialDrive1.tankDrive(leftPower, rightPower);
	}
	
	public void autoDrive(double power, double turnrate) {
		this.differentialDrive1.arcadeDrive(power, turnrate);
	}
}
